# 7.2 模擬處理器快取行為

就算快取的運作原理相當容易理解，但實際程式究竟如何與快取互動並不容易觀察。其實程式設計師並不在乎資料所在的記憶體位置。記憶體位址產生可是由鏈接器 (Linker) 或在運行當下由動態鏈接器與作業系統決定。產生的組合語言能夠處理所有可能的記憶體位址。所以在程式碼中，甚至看不到任何關於記憶體位置的線索。也因為如此要理解程式如何使用記憶體真的非常的困難。

我們在 7.1 節所提到的 CPU 層面的分析工具像 oprofile 有助於我們了解快取的使用情況。其所有數據都是直接由硬體所收集，在不追求高精度的狀況下十分的好用。一旦牽涉需要高精度的資料時，oprofile 就派不上用場了；線程可能會被中斷非常多次。因此若是要查看程式在不同處理器上的記憶體使用行為，實際上必須湊齊這些不同的機台並直接在上面做實驗。但往往窒礙難行。像圖 3.8 的數據。若是要使用 oprofile 收集這些資料，必須要有 24 台不同的機器，但其中許多機器根本不存在。

<figure>
  <img src="../assets/figure-7.5.png" alt="圖 7.5：cachegrind 統計結果">
  <figcaption>圖 7.5：cachegrind 統計結果</figcaption>
</figure>

圖中的結果是使用快取模擬器所得到。[`cachegrind`](https://valgrind.org/docs/manual/cg-manual.html) 使用 valgrind 框架，是為了檢查程式中的記憶體運用相關問題而開發。`valgrind` 模擬程式執行過程並在執行期間可以使用各種擴充功能，例如 `cachegrind` ，來竄入執行框架。`cachegrind` 利用這個功能來攔截紀錄所有記憶體地址的使用狀況，然後模擬所有 `L1i` 、`L1d` 和 `L2` 快取在任何指定資料大小的行為。若要使用這個功能，必須在使用 `valgrind` 時給定參數如下：

```c
valgrind --tool=cachegrind command arg
```

上圖的範例同時模擬三個快取以及對應的資料大小與處理器。當程序正在運行時，部分結果會寫入到 `stderr`，其中包含快取的總使用統計結果，如圖 7.5 所示。圖中顯示指令和記憶體位置參考的總數以及 `L1i/L1d` 和 `L2`  快取產生的未命中次數、未命中率等等。該工具甚至可以將 `L2` 存取細分為指令存取和資料存取，所有資料快取都區分為讀取和寫入兩種不同行為。

有了基礎的認知之後我們可以透過給予不同的參數來進行更複雜的操作。 使用 `--I1` 、 `--D1` 和 `--L2` 參數，`cachegrind` 可以忽略處理器的快取結構，模擬使用參數所指定的結構。 如下：

```c
valgrind --tool=cachegrind \
--L2=8388608,8,64 command arg
```

模擬 8MB 的 L2 快取大小並支援 8-way set, 每個快取行的大小是 64 bytes。 注意 `--L2` 需要放在 `command arg` 的前面。

當然 cachegrind 還可以支援更多事情。在行程結束之前，它會產生一個 `cachegrind.out.XXXXX` 檔，其中 `XXXXX` 是行程的 `PID` 。這個檔案包含了程式中每個函式和原始程式碼中快取使用的摘要和詳細內容。可以使用 `cg annotate` 來查看這些資料。

程式所產生的結果包含了快取使用摘要，以及每個函式對快取使用的詳細摘要。要獲得資料需要 `cg annotate` 能夠將記憶體位置與函式做配對，這表示最好要有除錯相關的資訊。若是沒有，雖然 `ELF` 檔案可以提供一些幫助，但是由於內部符號 (internal symbol) 沒有列在動態符號表中，因此結果不夠完整。圖 7.6 顯示了與圖 7.5 相同的程式運行的部分結果。

<figure>
  <img src="../assets/figure-7.6.png" alt="圖 7.6：cg annotate 結果">
  <figcaption>圖 7.6：cg annotate 結果</figcaption>
</figure>

`Ir` 、`Dr` 和 `Dw` 這幾個欄位顯示的是總快取使用量，而非快取未命中數，這些未命中次數會在後面兩欄顯示。這些數據可以用於辨識出產生最多快取未命中的程式碼。首先可以先關注 `L2` 的快取未命中，再延伸處理 `L1i/L1d` 快取未命中。

`cg annotate` 可以提供更詳細的資料。如果有特別指定某一個檔案，甚至可以逐行顯示出對應的快取命中數和未命中數。這些資訊可以讓程式撰寫者可以深入到確切行數。雖然程式介面有點粗糙：我正撰寫本文時，cachegrind 資料檔案和原始檔必須在同一個目錄中。

再次強調一下，`cachegrind` 是一個模擬器，不會使用來自處理器的測量數值。因此與處理器中實際的快取實做方式很可能會非常不同。`cachegrind` 使用 LRU 淘汰策略，但對於具有高關聯性的高速快取而言，這會造成額外的成本。除此之外，模擬器並沒有考慮 `context switch` 和系統呼叫 (System call) ，這兩者都可能破壞大部分 L2 快取並必須更新 L1i 和 L1d 的快取內容。這會導致模擬結果的總快取失誤數低於實際的狀況。儘管如此，`cachegrind` 還是一個很好的工具，可以了解程式的記憶體使用情況以及其相關的問題。