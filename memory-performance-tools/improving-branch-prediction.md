# 7.4 改善分支預測

6.2.2節中，我們提到了兩個改善 L1i 使用的方法，分別是通過分支預測和重新排序區塊：通過 `__builtin_expect` 進行靜態預測和狀態偵測的最佳化（PGO）。正確的分支預測對軟體的性能有巨大的影響，但在這裡我們會著重在記憶體使用的改善狀況。

使用 `__builtin_expect` （或 `likely` 和 `unlikely` 兩個巨集）的方式非常簡單。只要把相關的定義放在中央標頭檔裡，編譯器就可以發會作用。但有個小問題，隨然對於軟體工程師來說，有可能在需要使用 `likely` 的狀況卻使用 `unlikely` ，反之亦然。即使可以使用類似 oprofile 的工具來測量分支預測錯誤和 L1i 未命中，但這些問題仍然很難抓漏。

雖然如此但還是有一個簡單的方法。A.2 節的程式碼另外定義了 `likely` 和 `unlikely` 兩的巨集，它可以在程式執行階段主動測量靜態預測是否正確。而且使用者或測試人員可以就檢查結果進行調整。但測量實際上不會考慮到程式的性能，只會測試程式設計師所做的靜態假設。詳細內容以及程式碼可以在上面的章節中找到。

PGO 對於 gcc 來說相當容易使用。總共只需要三個步驟，但必須滿足某些要求。首先，所有的來源檔案都必須使用額外的 `-fprofile-generate` 選項進行編譯。這個選項必須被傳遞到所有的編譯器運行的程式或鍊結該程式的命令中。雖然可以混合使用已啟用和未啟用此選項的檔案，但對於沒有啟用此選項的目標檔案，PGO 就不會被觸發。

編譯器所產生的二進位檔案除了速度非常慢與容量巨大之外與正常的無異，因為他記錄（和儲存）有關分支是否被採用等等相關資訊。編譯器還為每個輸入的檔案發出一個名為".gcno"的擴增檔案。這個檔案包含與程式碼中分支相關的資訊。這個檔案必須被保留以便後續使用。

當程式的二進位檔準備好時，它應該用來執行某個代表性工作的集合。不論使用哪種工作，二進位檔都會針對這項任務進行最佳化。程式的連續執行是可能的且通常必要；所有執行都會對同一個輸出檔案做出貢獻。在程式結束之前，收集的資料會寫入 `.gcda` 的擴增檔案中。這些文件會在包含源頭(source)檔案的目錄中新增。程式可以從任何目錄執行，並且二進位檔也可以任意複製，但是源頭目錄必須要具備可使用且可寫入的權限。同樣地，為每個輸入的源頭檔案創建一個輸出文件。如果多次啟動程式，必須要在源頭目錄中找到之前執行所留下的 `.gcda` 文件，否則後續執行的資料就無法累積在一個檔案中。

當執行一組代表性測試後，就可以來重新編譯應用程式。編譯器必須能夠在包含源頭檔案的同一目錄中找到 `.gcda` 檔。千萬不能移動這些檔案，否則編譯器會找不到，嵌入的檔案校驗也無法匹配。重新編譯時，要將將 `-fprofile-generate` 參數替換為 `-fprofile-use` 。最重要的是，原始碼不得以任何方式更改。更改空格和注釋沒問題，但如果加上更多分支或基本程式碼區塊會使收集的資料無效，更導致編譯失敗。

這些就是程式設計師所需要做；看起來很簡單對吧？最重要的是選擇最適合的工具來進行測量。如果測試工作不適合程式的實際使用方式，執行的結果可能會更遭。也因為如此，使用 PGO 來進行函式庫的最佳化通常非常困難。函式庫可以在許多情境中使用，除非使用案例確實相似，否則通常最好僅使用 `__builtin_expect` 的靜態分支預測。

而對 `.gcno` 和 `.gcda` 兩個檔案而言，有幾點需要注意。這些二進制檔案並不能直接用來檢查。但可以使用 gcc 套件中的 gcov 工具來進行檢視。這個工具主要用於覆蓋分析（因此得名），但使用的檔案格式與 PGO 相同。gcov 工具為每個包含執行程式碼的源頭文件（可能包括系統標頭）生成 `.gcov` 的擴增檔案。這些檔案是根據給定給 gcov 的參數進行註釋與列表，其中包括分支計數器、機率等資料。